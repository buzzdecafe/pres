<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=1024, user-scalable=no">

	<title>From Zero to Ramda</title>
	
	<!-- Required stylesheet -->
	<link rel="stylesheet" href="core/deck.core.css">
	
	<!-- Extension CSS files go here. Remove or add as needed. -->
	<link rel="stylesheet" href="extensions/goto/deck.goto.css">
	<link rel="stylesheet" href="extensions/menu/deck.menu.css">
	<link rel="stylesheet" href="extensions/navigation/deck.navigation.css">
	<link rel="stylesheet" href="extensions/status/deck.status.css">
	<link rel="stylesheet" href="extensions/hash/deck.hash.css">
	<link rel="stylesheet" href="extensions/scale/deck.scale.css">

  <!-- include code mirror default css and the theme you want. -->
  <link rel="stylesheet" href="extensions/codemirror/deck.codemirror.css">
  <link rel="stylesheet" href="extensions/codemirror/themes/default.css">

	<!-- Style theme. More available in /themes/style/ or create your own. -->
	<link rel="stylesheet" href="themes/style/mnml.css">
	
	<!-- Transition theme. More available in /themes/transition/ or create your own. -->
	<!--link rel="stylesheet" href="themes/transition/fade.css"-->

  <!-- Base codemiror code -->
  <script src="extensions/codemirror/codemirror.js"></script>

  <!-- Syntax highlighting Modes -->

	<!-- Required Modernizr file -->
	<script src="modernizr.custom.js"></script>
  <script src="https://cdn.jsdelivr.net/ramda/0.23.0/ramda.min.js"></script>

	<!-- My custom styles -->
	<link rel="stylesheet" href="css/mike.css">

</head>
<body class="deck-container">

<!-- Begin slides. Just make elements with a class of slide. -->
<section class="slide">
<h1 class="over">From Zero to Ramda</h1>
<div>
  <p style="text-align: center"><em>Practical functional JavaScript</em></p>
  <img src="img/ramdaFilled_200x235.png" />
</div>
</section>

<section class="slide">
  <h2>Motivation: It's all about <em class="hot">function composition</em></h2>
  <p><em>Function Composition</em> is the technique of chaining together functions to create a new function.</p>

  <div>
    <img src="img/function_machines_composed.png" />

  </div>
</section>

<section class="slide">
  <h2>Motivation: It's all about <em class="hot">function composition</em></h2>
  <h3>What exactly do you mean by "function"?</h3>
  <p>A function relates a set of inputs to a set of outputs.</p>
  <figure class="f">
    <img src="img/f.png" />
    <figcaption>f : X &rarr; Y</figcaption>
  </figure>
</section>

<section class="slide">
  <h2>What is a function?</h2>

  <div>
    <h3>Is this a function?</h3>
    <textarea id="isit1" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">function f(x) {
  return x * 2;
}
  </textarea>
  </div>

  <div class="slide">
    <h3 class="yup">YES</h3>
  </div>
  <div class="slide">
    <p>A function takes arguments and returns results.</p>
  </div>
</section>

<section class="slide">
  <h2>What is a function?</h2>

  <div>
    <h3>Is this a function?</h3>
    <textarea id="isit1" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">function f(x) {
  this.x = x; 
}
  </textarea>
  </div>

  <div class="slide">
    <h3 class="nope">NO</h3>
  </div>

  <div class="slide">
    <p>Functions only know about their arguments, and no other state. `this` is not an argument to `f`</p>
  </div>
</section>

<section class="slide">
  <h2>What is a function?</h2>

  <div>
    <h3>Is this a function?</h3>
    <textarea id="isit1" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">function f(x, y) {
  x.doubleY = y * 2;
  return x;
}
  </textarea>
  </div>

  <div class="slide">
    <h3 class="nope">NO</h3>
  </div>
  <div class="slide">
    <p>A function does not mutate its arguments.</p>
  </div>
</section>

<section class="slide">
  <h2>What is a function?</h2>

  <div>
    <h3>Is this a function?</h3>
    <textarea id="isit1" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">function f(x, xs) {
  xs.push(x);
  return xs;
}
  </textarea>
  </div>

  <div class="slide">
    <h3 class="nope">NO</h3>
  </div>
  <div class="slide">
    <p>A function does not mutate its arguments. (Didn't I just say that?)</p>
  </div>
</section>

<section class="slide">
  <h2>What is a function?</h2>

  <div>
    <h3>Is this a function?</h3>
    <textarea id="isit1" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">function f(xs) {
  var i = 0, out = [];
  for (i = 0, i < xs.length; i++) {
    out.push(xs[i] * 2);
  }
  return out;
}
    </textarea>
  </div>

  <div class="slide">
    <h3 class="yup">YES</h3>
  </div>

  <div class="slide">
    <p>Mutation of internal variables is permissible in the implementation of a JavaScript
    function.</p>
    <p>n.b.: In strict languages like Haskell, reassigning variables is not possible (although you <em>can</em> shadow them).</p>
  </div>
</section>

<section class="slide">
  <h2>What is a function?</h2>

  <div>
    <h3>Is this a function?</h3>
    <textarea id="isit1" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">function f(x, xs) {
  return xs.concat([x]);
}
  </textarea>
  </div>

  <div class="slide">
    <h3 class="yup">YUP</h3>
  </div>

  <div class="slide">
    <p>A function may take more than one argument.</p>
  </div>
</section>

<section class="slide">
  <h2>What is a function?</h2>

  <div>
    <h3>Is this a function?</h3>
    <textarea id="isit1" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">function f(x, document) {
  var s = x + "!!!";
  document.querySelector('#exclaim').textContent = s;
  return s; 
}
  </textarea>
  </div>

  <div class="slide">
    <h3 class="nope">NO</h3>
  </div>

  <div class="slide">
    <p>Functions do not perform side-effects.</p>
  </div>
</section>

<section class="slide">
  <h2>What is a function?</h2>

  <div>
    <h3>Is this a function?</h3>
    <textarea id="isit1" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">function f(x) {
  var obj = {};
  obj.x = x; 
}
  </textarea>
  </div>

  <div class="slide">
    <h3 class="nope">NO</h3>
  </div>

  <div class="slide">
    <p>Functions always return the value that results from their evaluation.</p>
  </div>
</section>

<section class="slide">
  <h2>What is a function?</h2>

  <div>
    <h3>Is this a function?</h3>
    <textarea id="isit1" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">function f(x) {
  var obj = {};
  obj.x = x; 
  return obj;
}
  </textarea>
  </div>

  <div class="slide">
    <h3 class="yup">YES</h3>
  </div>
  <div class="slide">
    <p>Functions always return the value that results from their evaluation.</p>
  </div>
</section>

<section class="slide">
  <h2>What is a function?</h2>

  <div>
    <h3>Is `g` a function?</h3>
    <textarea id="isit1" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">function f(x) {
  return function(y) {
    return x + y;
  };
}
var g = f(10); // is `g` a function by our definition so far?
  </textarea>
  </div>

  <div class="slide">
    <h3 class="yup">YES</h3>
  </div>
</section>

<section class="slide">
  <h2>What is a function?</h2>

  <div>
    <h3>Is `g` a function?</h3>
    <textarea id="isit1" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">function f(xs) {
  return function(y) {
    xs.push(y);
    return xs;
  };
}
var g = f([]);
  </textarea>
  </div>

  <div class="slide">
    <h3 class="nope">NO</h3>
  </div>
  <div class="slide">
    <p>Functions always return the same value for the same arguments. Consider calling `g(1)` twice in a row. What does it return each time?</p>
  </div>
</section>

<section class="slide">
  <h2>What is a function?</h2>

  <h3>Review</h3>

  <p>A function relates a set of inputs to a set of outputs.</p>

  <ul>
    <li>Functions take arguments and return results.</li>
    <li>Functions only know about their arguments, and no other state.</li>
    <li>Functions do not mutate their arguments.</li>
    <li>Functions may take any number of arguments; even zero.</li>
    <li>Functions do not perform side-effects.</li>
    <li>Functions always return the value that results from their evaluation.</li>
    <li>Functions always return the same value for the same arguments.</li>
  </ul>

  <p>(&hellip; and by the way: Mutation of internal variables is permissible in the implementation of a JavaScript function.)</p>
</section>

<section class="slide">
  <h2>What not to do:</h2>

  <ul>
    <li>Don't fail to return a value.</li>
    <li>Don't re-assign variables. (Once a variable has a value, it never changes.)</li>
    <li>Don't mutate arguments. In fact, all mutation should be avoided.</li>
    <li>Don't rely on any external state.</li>
    <li>Don't perform side-effects.</li>
  </ul>
</section>

<section class="slide">
  <h2>How to lose friends and alienate people</h2>
  
  <figure class="portrait">
    <img src="img/monk.jpg" />
    <figcaption>How Haskell programs are written</figcaption>
  </figure>
  <blockquote>
    <p>The functional programmer sounds rather like a medieval monk, denying himself 
    the pleasures of life in the hope that it will make him virtuous. </p>

    <p class="attrib">&mdash; John Hughes, "Why Functional Programming Matters" (1984)</p>
  </blockquote>


</section>

<section class="slide">
  <h2>Motivation: It's all about <em class="hot">function composition</em></h2>
  <figure class="f">
    <img src="img/f.png" />
    <figcaption>f : X &rarr; Y</figcaption>
  </figure>
  <figure class="f">
    <img src="img/g.png" />
    <figcaption>g : Y &rarr; Z</figcaption>
  </figure>

</section>

<section class="slide">
  <h2>Motivation: It's all about <em class="hot">function composition</em></h2>
  <figure class="f">
    <img src="img/fog.png" />
    <figcaption>f &#8728; g</figcaption>
  </figure>
  <figure class="f slide">
    <img src="img/h.png" />
    <figcaption>h : X &rarr; Z</figcaption>
  </figure>

</section>

<section class="slide">
  <h2>Composition Example</h2>
  <div>
    <textarea id="f_fn" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">// f :: String -> [String]
const f = s => s.split('');

// g :: Object -> String
const g = obj => obj.key;

// h :: Object -> [String]
const h = obj => f(g(obj));


console.log("f('abc') ->", f('abc'));
console.log("g({key: 'Alonzo Church'}) ->", g({key: 'Alonzo Church'}));
console.log("h({key: 'abcde'}) ->", h({key: 'abcde'}));
    </textarea>
  </div>
</section>

<section class="slide">
  <h2>Composition, Ramda-style</h2>
  <div>
    <textarea id="f_fn" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">// f :: String -> [String]
const f = R.split('');

// g :: Object -> String
const g = R.prop('key');

// h :: Object -> [String]
const h = R.compose(f, g); // same as R.compose(R.split(''), R.prop('key'))


console.log("f('abc') ->", f('abc'));
console.log("g({key: 'Alonzo Church'}) ->", g({key: 'Alonzo Church'}));
console.log("h({key: 'abcde'}) ->", h({key: 'abcde'}));
    </textarea>
  </div>
</section>

<section class="slide">
  <h2>What are the differences?</h2>
  <div>
    <h3>Plain ol' JavaScript</h3>
    <textarea id="f_fn" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">// f :: String -> [String]
const f = s => s.split('');

// g :: Object -> String
const g = obj => obj.key;

// h :: Object -> [String]
const h = obj => f(g(obj));


console.log("f('abc') ->", f('abc'));
console.log("g({key: 'Alonzo Church'}) ->", g({key: 'Alonzo Church'}));
console.log("h({key: 'abcde'}) ->", h({key: 'abcde'}));
    </textarea>
  </div>
  <div>
    <h3>Ramda-style</h3>
    <textarea id="f_fn" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">// f :: String -> [String]
const f = R.split('');

// g :: Object -> String
const g = R.prop('key');

// h :: Object -> [String]
const h = R.compose(f, g); // same as R.compose(R.split(''), R.prop('key'))


console.log("f('abc') ->", f('abc'));
console.log("g({key: 'Alonzo Church'}) ->", g({key: 'Alonzo Church'}));
console.log("h({key: 'abcde'}) ->", h({key: 'abcde'}));
    </textarea>
  </div>
</section>

<section class="slide">
  <h2>Currying</h2>
  <figure class="portrait">
    <img src="img/HaskellBCurry.jpg" />
    <figcaption>Haskell B. Curry</figcaption>
  </figure>

  <p><em class="hot">Currying</em> is the technique of translating the evaluation of a function that takes multiple arguments (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument.</p>

  <div>
    <textarea id="curry_explained_1" class="code" name="code" mode="javascript" style="display: none">// UNCURRIED:
// mult :: (Number, Number) => Number
const mult = (x, y) => x * y;

mult(10, 3); //=> 30
mult(10); //=> NaN


// CURRIED:
// cmult :: Number -> Number -> Number
const cmult = x => y => x * y;

const times10 = cmult(10); //=> a new Function from Number -> Number

times10(3); //=> 30
    </textarea>
  </div>
</section>

<section class="slide">
  <h2>Currying in Ramda</h2>

    <textarea id="R_curry" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const mult = (x, y) => x * y;
const rcmult = R.curry(mult);

console.log("You can call rcmult either way: ", rcmult(3)(10) === rcmult(3, 10));
console.log("rcmult(3, 10) ->", rcmult(3, 10));
console.log("rcmult(3)(10) ->", rcmult(3)(10));
    </textarea>
</section>

<section class="slide">
  <h2>Currying: What is it good for?</h2>

  <p>Remember: It's all about <em class="hot">composition</em>.<p>
  <p>Functions inside a composition take only one argument. By currying, 
  we can turn a function of any arity into a function that takes one argument.</p>
  <p>Currying enables us to reuse code by building new functions from simple parts.</p>

  <div class="slide">
    <h3>Example: <code>R.prop :: String -> Object -> Any</code></h3>
    <textarea id="R_curry_2" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const getName = R.prop('name'); // new function Object -> Any
const getAddr = R.prop('addr'); // new function Object -> Any
const getState = R.prop('state'); // new function Object -> Any
// etc.

console.log("getState({addr: '123 Main St.', state: 'CT'}) ->", getState({addr: '123 Main St.', state: 'CT'}));
    </textarea>
  </div>

</section>

<section class="slide">
  <h2>Currying in Ramda: What is it good for?</h2>
    <p>The best strategy for maximizing this reuse is to pass the <em>arguments least likely to change</em> into the function first.</p>
  <div class="slide">
    <h3>Example: <code>R.where :: Object -> Object -> Bool</code></h3>

    <p>
    Takes a spec object and a test object; returns true if the test satisfies the spec. Each of the spec's own properties must be a predicate function. Each predicate is applied to the value of the corresponding property of the test object. <code>where</code> returns true if all the predicates return true, false otherwise.
    </p>
    <textarea id="R_curry_2" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">// satisfiesInterface :: Object -> Bool
const satisfiesInterface = R.where({
  name: R.compose(R.equals('String'), R.type),
  state: R.equals('CT'),
  zip: R.compose(R.equals(5), R.length)
});

const goodOne = {
  name: 'Rusty',
  state: 'CT',
  zip: '06357'
};

const badOne = {
  state: 'CT',
  zip: '06357'
};

console.log("satisfiesInterface(goodOne) ->", satisfiesInterface(goodOne));
console.log("satisfiesInterface(badOne) ->", satisfiesInterface(badOne));
    </textarea>
  </div>
</section>

<section class="slide">
  <h2>Lists</h2>

  <div>
    <ul>
      <li><code>map</code></li>
      <li><code>filter</code></li>
      <li><code>reduce</code></li>
      <li><code>chain</code></li>
      <li><code>find</code></li>
    </ul>
  </div>

  <p>That's pretty much what you'll need. Any questions?</p>
</section>
<!--
<section class="slide">
  <h2>Lists: Quick digression</h2>

  <h3>Why not Array?</h3>
  <p><em>List</em> is a more fundamental data structure. It is defined recursively,
  and may be evaluated lazily.</p>

  <p><code>data List a = Nil | Cons (a, List a)</code></p> 
  <p><code>data Stream a = Nil | Cons (a, () -&gt; Stream a)</code></p> 

  <p><em>List</em> can be defined simply in terms of functions on pairs:</p>
  <textarea id="list" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const cons = (x, y) => f => f(x, y);
const car = f => f((x, y) => x);
const cdr = f => f((x, y) => y);
  </textarea>

</section>
-->

<section class="slide">
  <h2>Lists: <code>map</code></h2>

  <figure class="f">
    <img src="img/map.jpg" />
  </figure>
</section>

<section class="slide">
  <h2>Lists: <code>map</code></h2>

  <h3>Definition</h3>
  <p><code>R.map(f, xs)</code> creates a new list by applying the function <code>f</code> to every element in the list <code>xs</code></p> 


  <div class="slide showme">
    <h3>Pattern</h3>
    <table class="patterns">
      <tr>
        <th></th>
        <th>In</th>
        <th>Function</th>
        <th>Out</th>
      </tr>
      <tr>
        <td>map</td>
        <td><code>[&clubs; &clubs; &clubs;]</code></td>
        <td><code>&clubs; &rarr; &hearts;</code></td>
        <td><code>[&hearts; &hearts; &hearts;]</code></td>
      </tr>
    </table>
  </div>

  <div class="slide">
    <h3>When to use it</h3>
    <ul>
      <li>I have a function from &clubs; to &hearts;</li>
      <li>But instead of a &clubs;, I get a list of &clubs;, like [&clubs; &clubs; &clubs;].</li>
      <li>I want to apply my &clubs; &rarr; &hearts; function to all the &clubs; in the list and get a new list of &hearts;, i.e. [&hearts; &hearts; &hearts;]</li>
      <li>In other words, I want to <em>map the function <code>f</code> over the list <code>xs</code></em></li> 
      <li>In <em>other</em> other words, I want to <em>lift</em> the function &clubs; &rarr; &hearts; into list context. (How is that for code reuse?)</li>
    </ul>
    <p>Note that <code>map</code> can be for more than just lists. We'll get back to that idea later.</p>
  </div>
</section>

<section class="slide">
  <h2>Lists: <code>map</code></h2>
  <div>
    <h3>Example #1: Increment all items in a list</h3>
    <textarea id="map1" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const inc = n => n + 1;
const ns = [1, 2, 3];

const result = R.map(inc, ns);

console.log(result);
    </textarea>
  </div>

  <div class="slide">
    <h3>Example #2: Map elements to another type</h3>
    <textarea id="map2" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const ns = [114, 97, 109, 100, 97];
const result = R.map(String.fromCharCode, ns);

console.log(result);
    </textarea>
  </div>
</section>

<section class="slide">
  <h2>Lists: <code>map</code></h2>

  <h3>Example #2: Comparison</h3>
  <div>
    <textarea id="tomap1" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">var xs = ['a', 'b', 'c', 'd', 'e'];
var i, upper, out = [];

for (i = 0; i < xs.length; i++) {
  upper = xs[i].toUpperCase();
  out.push(upper)
}

console.log(out);
    </textarea>
  </div>

  <div class="slide">
    <textarea id="tomap2" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">var xs = ['a', 'b', 'c', 'd', 'e'];

const out = R.map(R.toUpper, xs);

console.log(out);
    </textarea>
  </div>
</section>

<section class="slide">
  <h2>Lists: <code>map</code></h2>

  <p>So what is the difference?
  It is all about <em class="hot">composition</em>.</p>

  <p>Suppose we need to daisy-chain these three transformations together:</p>
  <ul>
    <li>Increment a list of numbers</li>
    <li>Change to string by char code</li>
    <li>Convert to upper case</li>
  </ul>

</section>

<section class="slide">
  <h2>Lists: <code>map</code></h2>
  <h3>First try</h3>
  <div>
    <textarea id="mapcomp" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const xs = [113, 96, 108, 99, 96];
const allTheThings = R.compose(
  R.map(R.toUpper),
  R.map(String.fromCharCode),
  R.map(R.inc)
);
console.log(allTheThings(xs));
    </textarea>
  </div>

  <p class="slide">We can do better than this.</p>
  <div class="slide">
    <h3>Second try</h3>
    <textarea id="mapcomp2" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const xs = [113, 96, 108, 99, 96];
const allTheThings = R.map(
  R.compose(R.toUpper, String.fromCharCode, R.inc)
);
console.log(allTheThings(xs));
    </textarea>
  </div>

  <p class="slide">That's better! But we can pull out that composed function; maybe we can reuse it elsewhere.</p>
  <div class="slide">
    <h3>Third try</h3>
    <textarea id="mapcomp3" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const xs = [113, 96, 108, 99, 96];
const theThing = R.compose(R.toUpper, String.fromCharCode, R.inc); // naming things is hard
const allTheThings = R.map(theThing);
console.log(allTheThings(xs));
    </textarea>
  </div>
</section>


<section class="slide">
  <h2>Lists: <code>map</code></h2>
  <p>We can do these rewrites <em>confidently</em> because <code>map</code> must obey <em class="hot">laws</em></p>

  <figure>
    <img src="img/functor-laws.jpg" />
  </figure>
  
</section>


<section class="slide">
  <h2>Lists: <code>map</code> Laws</h2>

  <div>
    <h4>Identity Law</h4>
    <p><code>map id = id</code></p>
    <textarea id="map_id_law" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const id = x => x;

console.log(R.map(id, [1, 2, 3]), "equals", id([1, 2, 3]));
    </textarea>
  </div>

  <div>
    <h4>Composition Law</h4>
    <p><code>compose(map(f), map(g)) = map(compose(f, g))</code></p>
    <textarea id="map_compose_law" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const f = n => String.fromCharCode(n);
const g = n => n + 1;
const ns = [65, 66, 67];

console.log(R.compose(R.map(f), R.map(g))(ns), "equals", R.map(R.compose(f, g), (ns)));
    </textarea>
  </div>


</section>

<section class="slide">
  <h2>Lists: <code>map</code> Workshop</h2>

  <h3>Rewrite these examples as maps</h3>

  <div><p>#1</p>
    <textarea id="map_example1" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const xs = [{x: 1}, {x: 10}, {x: 100}, {x: 1000}];
var i = 0, out = [];
while (i < xs.length) {
  if (xs[i].x % 25 === 0) {
    out.push({x: -1});
  } else {
    xs[i].x = xs[i].x * 3;
    out.push(xs[i]);
  }
  i++;
}

console.log(out);
    </textarea>
  </div>
  <div><p>#2</p>
    <textarea id="map_example2" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const xs = [{seq: 1}, {seq: 4}, {seq: 5}, {seq: 7}];
var i = 0, result = [];
while(i < xs.length) {
  if (i === 0) {
    xs[i].seq = 1;
    result.push(xs[i]);
  } else {
    xs[i].seq = xs[i-1].seq + 1;
    result.push(xs[i]);
  }
  i++;
}

console.log(result);
    </textarea>
  </div>
  <div><p>#3</p>
    <textarea id="map_example3" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const xs = "q`lc`".split('');
var i = 0, out = [], y, c;
for (i = 0; i < xs.length; i++) {
  var y = xs[i].charCodeAt() + 1;
  out.push(String.fromCharCode(y).toUpperCase());
}

console.log(out.join(''));
    </textarea>
  </div>
</section>


<section class="slide">
  <h2>Lists: <code>map</code></h2>

  <h3>Things to remember about <code>map</code></h3>

  <ul>
    <li>Transforms everything inside a container</li>
    <li>Returns a container of the same shape</li>
    <li>Identity Law</li>
    <li>Composition Law</li>
  </ul>
</section>


<section class="slide">
  <h2>Lists: <code>filter</code></h2>

  <figure class="f">
    <img src="img/filter.jpg" />
  </figure>
</section>

<section class="slide">
  <h2>Lists: <code>filter</code></h2>
  <h3>Definition</h3>
  <p><code>R.filter(f, xs)</code> creates a new list by applying a predicate <code>f</code> to the list <code>xs</code>, and returns only the elements that satisfy the predicate.</p> 


  <div class="slide showme">
    <h3>Pattern</h3>
    <table class="patterns">
      <tr>
        <th></th>
        <th>In</th>
        <th>Function</th>
        <th>Out</th>
      </tr>
      <tr>
        <td>filter</td>
        <td><code>[&clubs; &clubs; &clubs;]</code></td>
        <td><code>&clubs; &rarr; Boolean</code></td>
        <td><code>[&clubs; &hellip;]</code></td>
      </tr>
    </table>
  </div>

  <div class="slide">
    <h3>When to use it</h3>
    <ul>
      <li>I want to select only certain elements of a list.</li> 
      <li>I have a function from &clubs; to Boolean that describes the elements I want.</li>
    </ul>
  </div>

</section>

<section class="slide">
  <h2>Lists: <code>filter</code></h2>
  <div>
    <h3>Example #1: Select numbers less than 10</h3>
    <textarea id="filter1" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const lt10 = n => n < 10;
const ns = [1, 10, 2, 20, 3, 30];

const result = R.filter(lt10, ns);

console.log(result);
    </textarea>
  </div>

  <div class="slide">
    <h3>Example #2: Return strings less than 5 characters long</h3>
    <textarea id="filter2" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const ns = ["this", "certainly", "is", "still", "acceptably", "good"];
const result = R.filter(x => x.length < 5, ns);

console.log(result);
    </textarea>
  </div>
</section>

<section class="slide">
  <h2>Lists: <code>filter</code></h2>

  <h3>Example #3: Comparison</h3>
  <div>
    <textarea id="tofilter3" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const ns = [1, 100, 2, 303, 11, 12, 4, 22, 0];
var i = 0, out = [];
for (i = 0; i < ns.length; i++) {
  if (ns[i] % 2 === 0) {
    out.push(ns[i]);
  }
}
console.log(out);
    </textarea>
  </div>

  <div class="slide">
    <textarea id="tofilter3" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const ns = [1, 100, 2, 303, 11, 12, 4, 22, 0];
var out = R.filter(x => x % 2 === 0, ns);
console.log(out);
    </textarea>
  </div>
</section>

<section class="slide">
  <h2>Lists: <code>filter</code></h2>

  <p>It is all about <em class="hot">composition</em>.</p>

</section>

<section class="slide">
  <h2>Lists: <code>filter</code></h2>
  <h3>You can rewrite this:</h3>
  <div>
    <textarea id="filtercomp" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const xs = [-20, 113, 96, -999, 108, 0, 99, -2, -15, 96];
const even = x => x % 2 === 0;
const positive = x => x > 0;

const positiveEvens = R.compose(
  R.filter(even),
  R.filter(positive)
);
console.log(positiveEvens(xs));
    </textarea>
  </div>

  <div class="slide">
    <h3>... like this:</h3>
    <textarea id="filtercomp2" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const xs = [113, 96, 108, 99, 96];
const even = x => x % 2 === 0;
const positive = x => x > 0;

const positiveEvens = R.filter(x => positive(x) && even(x));
console.log(positiveEvens(xs));
    </textarea>
  </div>

  <div class="slide">
    <h3>... or even like this:</h3>
    <textarea id="filtercompr3" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const xs = [113, 96, 108, 99, 96];
const even = x => x % 2 === 0;
const positive = x => x > 0;

const positiveEvens = R.filter(R.both(positive, even));
console.log(positiveEvens(xs));
    </textarea>
  </div>

  <div class="slide">
    <p>(... or if you have many predicates, maybe even 
    <code>R.filter(R.allPass([p1, p2, ..., pn], xs)</code>)
    </p>
  </div>
</section>


<section class="slide">
  <h2>Lists: <code>filter</code></h2>
  <p>Filter laws are a trickier matter -- let's table that. Nonetheless:</p>
  <p>We can do these rewrites <em>confidently on lists</em> because <code>filter</code> on lists 
  has some well-defined algebraic rules.</p>
</section>


<section class="slide">
  <h2>Lists: <code>filter</code> algebra</h2>

  <div>
    <code>filter(T) = id</code>
    <textarea id="filter_alg_1" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const T = x => true;
const xs = [1, 2, 3];

console.log(R.filter(T, xs), "equals", xs);
    </textarea>
  </div>

  <div>
    <code>filter(F) = Empty</code>
    <textarea id="filter_alg_2" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const F = x => false;
const xs = [1, 2, 3];

console.log(R.filter(F, xs), "equals", []);
    </textarea>
  </div>

  <div>
    <code>filter(f, []) = []</code>
    <textarea id="filter_alg_2" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const xs = [1, 2, 3];
const F = x => false;
const T = x => true;

console.log(R.filter(F, []), "equals", R.filter(T, []));
    </textarea>
  </div>
  <div>
    <code>concat(filter(f, xs), filter(f, ys)) = filter(f, concat(xs, ys))</code> 
    <textarea id="filter_alg_4" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const even = x => x % 2 === 0;
const xs = [1, 2, -3];
const ys = [10, 21, -30];

console.log(R.concat(R.filter(even, xs), R.filter(even, ys)), "equals", 
            R.filter(even, R.concat(xs, ys)));
    </textarea>
  </div>
</section>


<section class="slide">

  <h2>Lists: <code>filter</code> algebra (continued)</h2>
  <div>
    <h3>Conjunction</h3>
    <code>filter(f, filter(g, xs)) = filter(x => f(x) && g(x), xs)</code>
    <textarea id="filter_alg_3" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const even = x => x % 2 === 0;
const positive = x => x > 0;
const xs = [-2, 1, 2, 3, 4];

console.log(R.filter(even, R.filter(positive, xs)), "equals", 
            R.filter(R.both(even, positive), xs));
    </textarea>
  </div>

  <div>
    <h3>Commutativity</h3>
    <code>filter(f, filter(g, xs)) = filter(g, (filter(f, xs))</code> 
    <textarea id="filter_alg_4" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const even = x => x % 2 === 0;
const positive = x => x > 0;
const xs = [1, 2, 3, 4, -8];

console.log(R.filter(even, R.filter(positive, xs)), "equals", 
            R.filter(positive, R.filter(even, xs)));
    </textarea>
  </div>

</section>

<section class="slide">
  <h2>Lists: <code>filter</code> Workshop</h2>

  <h3>Rewrite these examples as filter</h3>

  <div><p>#1</p>
    <textarea id="filter_example1" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">var xs = [4, 9, 1, 3, 2, 1, 0, 1, 7], i = 0, matches = [], value = 1;
for (i = 0; i < xs.length; i++) {
  if (xs[i] === value) {
    matches.push(i);
  }
}
console.log(matches);
    </textarea>
  </div>
  <div><p>#2</p>
    <textarea id="filter_example2" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">var xs = ['a', 'B', 'c', 'X', 'y', 'Z'], result = [], i = 0;
while (i < xs.length) {
  if (xs[i].toUpperCase() === xs[i]) {
    result = result.concat(xs[i]);
  }
  i++;
}
console.log(result);
    </textarea>
  </div>
  <div><p>#3</p>
    <textarea id="filter_example3" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">var xs = [4, 9, 1, 3, 2, 1, 0, 1, 7], out = [], i = 0;
xs.forEach(function(x) {
  if (x > 2) {
    if (x % 2 === 1) {
      out.push(i);
    }
  }
});
console.log(out);
    </textarea>
  </div>
</section>

<section class="slide">
  <h2>Lists: <code>filter</code></h2>

  <h3>Things to remember about <code>filter</code></h3>

  <ul>
    <li>Rewrite-able with rules of filter algebra</li>
    <li>Filter relies on something that can be Empty</li>
    <li>Filter is bound up with the notion of <code>concat</code></li>
  </ul>
</section>


<section class="slide">
  <h2>Lists: <code>reduce</code></h2>


  <figure class="f">
    <img src="img/fold.png" />
    <figcaption>Reduce is also known as "fold"</figcaption>
  </figure>
</section>


<section class="slide">
  <h2>Lists: <code>reduce</code></h2>

  <h3>Definition</h3>
  <p><code>R.reduce(f, accumulator, xs)</code> creates a new accumulator by applying <code>f</code> to the accumulator along with each element of <code>xs</code>.</p> 


  <div class="slide showme">
    <h3>Pattern</h3>
    <table class="patterns">
      <tr>
        <th></th>
        <th>In</th>
        <th>Function</th>
        <th>Out</th>
      </tr>
      <tr>
        <td>reduce</td>
        <td><code>[&clubs; &clubs; &clubs;]</code></td>
        <td><code>(&diams;, &clubs;) &rarr; &diams;</code></td>
        <td><code>&diams;</code></td>
      </tr>
    </table>
  </div>

  <div class="slide">
    <h3>When to use it</h3>
    <ul>
      <li>I have [&clubs;] and I want to get a different-shaped output; e.g. to sum over a list; To join a list of strings, etc.</li> 
      <li>I want to go list to list, but it isn't a map or a filter.</li>
    </ul>

</section>

<section class="slide">
  <!--h2>Lists: <code>reduce</code></h2-->

  <figure class="f">
    <img src="img/resp.jpg" />
  </figure>

  </div>
</section>

<section class="slide">
  <h2>Lists: <code>reduce</code></h2>
  <div>
    <h3>Example #1: Sum a list of numbers</h3>
    <textarea id="fold1" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const ns = [1, 10, 2, 20, 3, 30];

const result = R.reduce((a, b) => a + b, 0, ns);

console.log(result);
    </textarea>
  </div>

  <div class="slide">
    <h3>Example #2: Turn an array of pairs into an object</h3>
    <textarea id="fold2" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const ns = [["a", 1], ["b", 2], ["c", 3], ["d", 444]];

const result = R.reduce((acc, x) => {
  acc[x[0]] = x[1];
  return acc;
}, {}, ns);

console.log(result);
    </textarea>
  </div>
</section>

<section class="slide">
  <h2>Lists: <code>reduce</code></h2>

  <h3>Example #3: Comparison</h3>
  <div>
    <textarea id="fold3" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const ns = [1, 100, 2, 303, 11, 12, 4, 22, 0];
var i = 0, out = [];
for (i = 0; i < ns.length; i++) {
  if (ns[i] % 2 === 0) {
    out.push(ns[i]);
  }
}
console.log(out);
    </textarea>
  </div>

  <div class="slide">
    <textarea id="fold4" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const ns = [1, 100, 2, 303, 11, 12, 4, 22, 0];
var out = R.filter(x => x % 2 === 0, ns);
console.log(out);
    </textarea>
  </div>
</section>

<section class="slide">
  <h2>Lists: <code>filter</code></h2>

  <p>It is all about <em class="hot">composition</em>.</p>

</section>

<section class="slide">
  <h2>Lists: <code>filter</code></h2>
  <h3>You can rewrite this:</h3>
  <div>
    <textarea id="filtercomp" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const xs = [-20, 113, 96, -999, 108, 0, 99, -2, -15, 96];
const even = x => x % 2 === 0;
const positive = x => x > 0;

const positiveEvens = R.compose(
  R.filter(even),
  R.filter(positive)
);
console.log(positiveEvens(xs));
    </textarea>
  </div>

  <div class="slide">
    <h3>... like this:</h3>
    <textarea id="filtercomp2" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const xs = [113, 96, 108, 99, 96];
const even = x => x % 2 === 0;
const positive = x => x > 0;

const positiveEvens = R.filter(x => positive(x) && even(x));
console.log(positiveEvens(xs));
    </textarea>
  </div>

  <div class="slide">
    <h3>... or even like this:</h3>
    <textarea id="filtercompr3" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const xs = [113, 96, 108, 99, 96];
const even = x => x % 2 === 0;
const positive = x => x > 0;

const positiveEvens = R.filter(R.both(positive, even));
console.log(positiveEvens(xs));
    </textarea>
  </div>

  <div class="slide">
    <p>(... or if you have many predicates, maybe even 
    <code>R.filter(R.allPass([p1, p2, ..., pn], xs)</code>)
    </p>
  </div>
</section>


<section class="slide">
  <h2>Lists: <code>filter</code></h2>
  <p>Filter laws are a trickier matter -- let's table that. Nonetheless:</p>
  <p>We can do these rewrites <em>confidently on lists</em> because <code>filter</code> on lists 
  has some well-defined algebraic rules.</p>
</section>


<section class="slide">
  <h2>Lists: <code>filter</code> algebra</h2>

  <div>
    <code>filter(T) = id</code>
    <textarea id="filter_alg_1" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const T = x => true;
const xs = [1, 2, 3];

console.log(R.filter(T, xs), "equals", xs);
    </textarea>
  </div>

  <div>
    <code>filter(F) = Empty</code>
    <textarea id="filter_alg_2" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const F = x => false;
const xs = [1, 2, 3];

console.log(R.filter(F, xs), "equals", []);
    </textarea>
  </div>

  <div>
    <code>filter(f, []) = []</code>
    <textarea id="filter_alg_2" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const xs = [1, 2, 3];
const F = x => false;
const T = x => true;

console.log(R.filter(F, []), "equals", R.filter(T, []));
    </textarea>
  </div>
  <div>
    <code>concat(filter(f, xs), filter(f, ys)) = filter(f, concat(xs, ys))</code> 
    <textarea id="filter_alg_4" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const even = x => x % 2 === 0;
const xs = [1, 2, -3];
const ys = [10, 21, -30];

console.log(R.concat(R.filter(even, xs), R.filter(even, ys)), "equals", 
            R.filter(even, R.concat(xs, ys)));
    </textarea>
  </div>
</section>


<section class="slide">

  <h2>Lists: <code>filter</code> algebra (continued)</h2>
  <div>
    <h3>Conjunction</h3>
    <code>filter(f, filter(g, xs)) = filter(x => f(x) && g(x), xs)</code>
    <textarea id="filter_alg_3" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const even = x => x % 2 === 0;
const positive = x => x > 0;
const xs = [-2, 1, 2, 3, 4];

console.log(R.filter(even, R.filter(positive, xs)), "equals", 
            R.filter(R.both(even, positive), xs));
    </textarea>
  </div>

  <div>
    <h3>Commutativity</h3>
    <code>filter(f, filter(g, xs)) = filter(g, (filter(f, xs))</code> 
    <textarea id="filter_alg_4" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const even = x => x % 2 === 0;
const positive = x => x > 0;
const xs = [1, 2, 3, 4, -8];

console.log(R.filter(even, R.filter(positive, xs)), "equals", 
            R.filter(positive, R.filter(even, xs)));
    </textarea>
  </div>

</section>

<section class="slide">
  <h2>Lists: <code>filter</code> Workshop</h2>

  <h3>Rewrite these examples as filter</h3>

  <div><p>#1</p>
    <textarea id="filter_example1" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">var xs = [4, 9, 1, 3, 2, 1, 0, 1, 7], i = 0, matches = [], value = 1;
for (i = 0; i < xs.length; i++) {
  if (xs[i] === value) {
    matches.push(i);
  }
}
console.log(matches);
    </textarea>
  </div>
  <div><p>#2</p>
    <textarea id="filter_example2" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">var xs = ['a', 'B', 'c', 'X', 'y', 'Z'], result = [], i = 0;
while (i < xs.length) {
  if (xs[i].toUpperCase() === xs[i]) {
    result = result.concat(xs[i]);
  }
  i++;
}
console.log(result);
    </textarea>
  </div>
  <div><p>#3</p>
    <textarea id="filter_example3" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">var xs = [4, 9, 1, 3, 2, 1, 0, 1, 7], out = [], i = 0;
xs.forEach(function(x) {
  if (x > 2) {
    if (x % 2 === 1) {
      out.push(i);
    }
  }
});
console.log(out);
    </textarea>
  </div>
</section>

<section class="slide">
  <h2>Lists: <code>filter</code></h2>

  <h3>Things to remember about <code>filter</code></h3>

  <ul>
    <li>Rewrite-able with rules of filter algebra</li>
    <li>Filter relies on something that can be Empty</li>
    <li>Filter is bound up with the notion of <code>concat</code></li>
  </ul>
</section>

<section class="slide">
  <h2>Lists: <code>map, filter, reduce</code></h2>

  <p>You can stop here and probably be perfectly happy and productive.</p>
</section>

<section class="slide">
  <h2>Lists: <code>chain</code></h2>

</section>


<section class="slide">
  <h2>Lists: <code>find</code></h2>

  <p>There is something <em>different</em> about <code>find</code> &hellip;</p>

</section>

<section class="slide">
  <h2>Digression: Partial &amp; Total functions</h2>

  <p><code>find</code> is a partial function.</p>
  <p><code>map, filter, reduce, chain</code> are total functions.</p>

  <h3>Why should I care if my function is partial?</h3>

  <h3>How do I make a partial function a total function?</h3>
</section>

<section class="slide">
  <h2>Lists: <code>map, filter, reduce, find, chain</code> Workshop</h2>
  <h3>Identify the pattern and rewrite</h3>
</section>


<section class="slide">
  <h2>Lists & Composition</h2>

  <p>How would you write a function to get the sum of a 2D matrix? For example,
  given a matrix <code>[[1, 2], [3, 4]]</code>, your function should return <code>10</code>
  </p>

  <div>
    <textarea id="mxSum2" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const mx = [
  [2, 34, 1, 17],
  [5, 9, 11, 10],
  [21, 11, 1, 3],
  [44, 15, 8, 12]
];
const mxSum2 = mx => {
  // return the sum of the matrix
}
    </textarea>
  </div>
</section>

<section class="slide">
  <h2>Lists & Composition</h2>

  <p>Here's a nice way to do it:</p>

  <div>
    <textarea id="mxSum2_solution" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const mx = [
  [2, 34, 1, 17],
  [5, 9, 11, 10],
  [21, 11, 1, 3],
  [44, 15, 8, 12]
];

// 1. start with a helper that adds two numbers
const add = (x, y) => x + y;

// 2. another helper to fold `add` over a list
const sum = R.reduce(add, 0);

// 3. Compose
const mxSum2 = R.compose(sum, R.map(sum)); 

console.log("mxSum2(mx) equals", mxSum2(mx));
    </textarea>
  </div>
</section>

<section class="slide">
  <h2>Lists & Composition</h2>

  <p>That was fun! Now let's write a function for a 3D matrix.
  </p>

  <div class="slide">
    <textarea id="mxSum3_solution" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">
const mxSum3 = R.compose(sum, R.map(mxSum2)); 
    </textarea>
  </div>

  <p class="slide">How about 4D?</p>
  <div class="slide">
    <textarea id="mxSum4_solution" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">
const mxSum4 = R.compose(sum, R.map(mxSum3)); 
    </textarea>
  </div>

  <div class="slide">
    <p> &hellip; and so on. </p>


  </div>
</section>

<section class="slide">
  <h2>Lists & Composition</h2>

  <p>Let's write a function for a <em>N</em>-dimensional matrix.</p>
  <p>What pattern is would that be?</p>
</section>

<section class="slide">
  <h2>Functor</h2>

</section>

<section class="slide">
  <h2>Monoid</h2>

</section>



<section class="slide">
<h2>Final Thought</h2>

<blockquote>Simplicity is hard work. But, there's a huge payoff. The 
  person who has a genuinely simpler system&mdash;a system made out of 
  genuinely simple parts&mdash;is going to be able to affect the greatest 
  change with the least work. He's going to kick your ass. He's gonna 
  spend more time simplifying things up front and in the long haul 
  he's gonna wipe the plate with you because he'll have that ability 
  to change things when you're struggling to push elephants around.
  
  <p>&mdash; Rich Hickey</p>
</blockquote>

<div>
  <img src="img/push-elephant.jpg" />
</div>
</section>


<!-- End slides. -->


<!-- Begin extension snippets. Add or remove as needed. -->

<!-- deck.navigation snippet -->
<a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
<a href="#" class="deck-next-link" title="Next">&#8594;</a>

<!-- deck.status snippet -->
<p class="deck-status">
	<span class="deck-status-current"></span>
	/
	<span class="deck-status-total"></span>
</p>

<!-- deck.goto snippet -->
<form action="." method="get" class="goto-form">
	<label for="goto-slide">Go to slide:</label>
	<input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
	<datalist id="goto-datalist"></datalist>
	<input type="submit" value="Go">
</form>

<!-- deck.hash snippet -->
<a href="." title="Permalink to this slide" class="deck-permalink">#</a>

<!-- End extension snippets. -->


<!-- Required JS files. -->
<script src="jquery-1.7.2.min.js"></script>
<script src="core/deck.core.js"></script>

<!-- Extension JS files. Add or remove as needed. -->
<script src="extensions/hash/deck.hash.js"></script>
<script src="extensions/menu/deck.menu.js"></script>
<script src="extensions/goto/deck.goto.js"></script>
<script src="extensions/status/deck.status.js"></script>
<script src="extensions/navigation/deck.navigation.js"></script>
<!--script src="extensions/scale/deck.scale.js"></script-->

<!-- include the base codemirror code. -->
<script src="extensions/codemirror/codemirror.js"></script>

<!-- javascript -->
<script src="extensions/codemirror/mode/javascript/javascript.js"></script>

<!-- Plugin code -->
<script src="extensions/codemirror/deck.codemirror.js"></script>

<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>
	$(function() {
		$.deck('.slide');
	});
</script>
</body>
</html>
