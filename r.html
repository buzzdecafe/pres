<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=1024, user-scalable=no">

	<title>Ramda.js</title>
	
	<!-- Required stylesheet -->
	<link rel="stylesheet" href="core/deck.core.css">
	
	<!-- Extension CSS files go here. Remove or add as needed. -->
	<link rel="stylesheet" href="extensions/goto/deck.goto.css">
	<link rel="stylesheet" href="extensions/menu/deck.menu.css">
	<link rel="stylesheet" href="extensions/navigation/deck.navigation.css">
	<link rel="stylesheet" href="extensions/status/deck.status.css">
	<link rel="stylesheet" href="extensions/hash/deck.hash.css">
	<link rel="stylesheet" href="extensions/scale/deck.scale.css">

  <!-- include code mirror default css and the theme you want. -->
  <link rel="stylesheet" href="extensions/codemirror/deck.codemirror.css">
  <link rel="stylesheet" href="extensions/codemirror/themes/default.css">

	<!-- Style theme. More available in /themes/style/ or create your own. -->
	<link rel="stylesheet" href="themes/style/mnml.css">
	
	<!-- Transition theme. More available in /themes/transition/ or create your own. -->
	<!--link rel="stylesheet" href="themes/transition/fade.css"-->

  <!-- Base codemiror code -->
  <script src="extensions/codemirror/codemirror.js"></script>

  <!-- Syntax highlighting Modes -->

	<!-- Required Modernizr file -->
	<script src="modernizr.custom.js"></script>
  <script src="https://cdn.jsdelivr.net/ramda/0.23.0/ramda.min.js"></script>

	<!-- My custom styles -->
	<link rel="stylesheet" href="css/mike.css">

</head>
<body class="deck-container">

<!-- Begin slides. Just make elements with a class of slide. -->
<section class="slide">
<h1 class="over">Ramda.js</h1>
<div>
  <p style="text-align: center"><em>Practical functional JavaScript</em></p>
  <img src="img/ramdaFilled_200x235.png" />
</div>
</section>

<section class="slide">
  <h2>Motivation: It's all about <em class="hot">function composition</em></h2>
  <p><em>Function Composition</em> is the technique of chaining together functions to create a new function.</p>

  <div>
    <img src="img/function_machines_composed.png" />

  </div>
  <!--
  <textarea id="example1" name="example1" class="code" mode="javascript" style="display: none;">// Simple composition
const trim = str => str.replace(/^\s*|\s*$/g, '');
const capitalize = str => str.toUpperCase();

const convert = compose(trim, capitalize); // Look ma! New function!
  </textarea>
  -->
</section>

<section class="slide">
  <h2>Motivation: It's all about <em class="hot">function composition</em></h2>
  <img src="img/f.svg" />
  <img src="img/g.svg" />

</section>

<section class="slide">
  <h2>Motivation: It's all about <em class="hot">function composition</em></h2>
  <img src="img/fog.svg" />
  <img src="img/h.svg" class="slide" />

</section>

<section class="slide">
  <h2>Composition Example</h2>
  <div>
    <textarea id="f_fn" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">// f :: String -> [String]
const f = s => s.split('');

// g :: Object -> String
const g = obj => obj.key;

// h :: Object -> [String]
const h = obj => f(g(obj));


console.log("f('abc') ->", f('abc'));
console.log("g({key: 'Alonzo Church'}) ->", g({key: 'Alonzo Church'}));
console.log("h({key: 'abcde'}) ->", h({key: 'abcde'}));
    </textarea>
  </div>
</section>

<section class="slide">
  <h2>Composition, Ramda-style</h2>
  <div>
    <textarea id="f_fn" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">// f :: String -> [String]
const f = R.split('');

// g :: Object -> String
const g = R.prop('key');

// h :: Object -> [String]
const h = R.compose(f, g); // same as R.compose(R.split(''), R.prop('key'))


console.log("f('abc') ->", f('abc'));
console.log("g({key: 'Alonzo Church'}) ->", g({key: 'Alonzo Church'}));
console.log("h({key: 'abcde'}) ->", h({key: 'abcde'}));
    </textarea>
  </div>
</section>

<section class="slide">
  <h2>What are the differences?</h2>
  <div>
    <h3>Plain ol' JavaScript</h3>
    <textarea id="f_fn" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">// f :: String -> [String]
const f = s => s.split('');

// g :: Object -> String
const g = obj => obj.key;

// h :: Object -> [String]
const h = obj => f(g(obj));


console.log("f('abc') ->", f('abc'));
console.log("g({key: 'Alonzo Church'}) ->", g({key: 'Alonzo Church'}));
console.log("h({key: 'abcde'}) ->", h({key: 'abcde'}));
    </textarea>
  </div>
  <div>
    <h3>Ramda-style</h3>
    <textarea id="f_fn" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">// f :: String -> [String]
const f = R.split('');

// g :: Object -> String
const g = R.prop('key');

// h :: Object -> [String]
const h = R.compose(f, g); // same as R.compose(R.split(''), R.prop('key'))


console.log("f('abc') ->", f('abc'));
console.log("g({key: 'Alonzo Church'}) ->", g({key: 'Alonzo Church'}));
console.log("h({key: 'abcde'}) ->", h({key: 'abcde'}));
    </textarea>
  </div>
</section>

<section class="slide">
  <h2>Currying</h2>
  <figure class="portrait">
    <img src="img/HaskellBCurry.jpg" />
    <figcaption>Haskell B. Curry</figcaption>
  </figure>

  <p><em class="hot">Currying</em> is the technique of translating the evaluation of a function that takes multiple arguments (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument.</p>

  <div>
    <textarea id="curry_explained_1" class="code" name="code" mode="javascript" style="display: none">// UNCURRIED:
// mult :: (Number, Number) => Number
const mult = (x, y) => x * y;

mult(10, 3); //=> 30
mult(10); //=> NaN


// CURRIED:
// cmult :: Number -> Number -> Number
const cmult = x => y => x * y;

const times10 = cmult(10); //=> a new Function from Number -> Number

times10(3); //=> 30
    </textarea>
  </div>
</section>

<section class="slide">
  <h2>Currying in Ramda</h2>

    <textarea id="R_curry" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const mult = (x, y) => x * y;
const rcmult = R.curry(mult);

console.log("You can call rcmult either way: ", rcmult(3)(10) === rcmult(3, 10));
console.log("rcmult(3, 10) ->", rcmult(3, 10));
console.log("rcmult(3)(10) ->", rcmult(3)(10));
    </textarea>
</section>

<section class="slide">
  <h2>Currying: What is it good for?</h2>

  <p>Remember: It's all about <em class="hot">composition</em>.<p>
  <p>Functions inside a composition take only one argument.</p>
  <p>Currying enables us to reuse code by building new functions from simple parts.</p>

  <div class="slide">
    <h3>Example: <code>R.prop :: String -> Object -> Any</code></h3>
    <textarea id="R_curry_2" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const getName = R.prop('name'); // new function Object -> Any
const getAddr = R.prop('addr'); // new function Object -> Any
const getState = R.prop('state'); // new function Object -> Any
// etc.

console.log("getState({addr: '123 Main St.', state: 'CT'}) ->", getState({addr: '123 Main St.', state: 'CT'}));
    </textarea>
  </div>

</section>

<section class="slide">
  <h2>Currying in Ramda: What is it good for?</h2>
    <p>The best strategy for maximizing this reuse is to pass the <em>arguments least likely to change</em> into the function first.</p>
  <div class="slide">
    <h3>Example: <code>R.where :: Object -> Object -> Bool</code></h3>

    <p>
    Takes a spec object and a test object; returns true if the test satisfies the spec. Each of the spec's own properties must be a predicate function. Each predicate is applied to the value of the corresponding property of the test object. <code>where</code> returns true if all the predicates return true, false otherwise.
    </p>
    <textarea id="R_curry_2" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">// satisfiesInterface :: Object -> Bool
const satisfiesInterface = R.where({
  name: R.compose(R.equals('String'), R.type),
  state: R.equals('CT'),
  zip: R.compose(R.equals(5), R.length)
});

const goodOne = {
  name: 'Rusty',
  state: 'CT',
  zip: '06357'
};

const badOne = {
  state: 'CT',
  zip: '06357'
};

console.log("satisfiesInterface(goodOne) ->", satisfiesInterface(goodOne));
console.log("satisfiesInterface(badOne) ->", satisfiesInterface(badOne));
    </textarea>
  </div>
</section>

<section class="slide">
  <h2>Lists</h2>

  <div>
    <ul>
      <li><code>map</code></li>
      <li><code>filter</code></li>
      <li><code>reduce</code></li>
      <li><code>chain</code></li>
      <li><code>find</code></li>
    </ul>
  </div>

  <p>That's pretty much what you'll need. Any questions?</p>
</section>

<section class="slide">
  <h2>Lists: <code>map</code></h2>

  <h3>Definition</h3>
  <p><code>R.map(f, xs)</code> creates a new list by applying the function <code>f</code> to every element in the list <code>xs</code></p> 


  <div class="slide showme">
    <h3>Pattern</h3>
    <table class="patterns">
      <tr>
        <th></th>
        <th>In</th>
        <th>Function</th>
        <th>Out</th>
      </tr>
      <tr>
        <td>map</td>
        <td><code>[&clubs; &clubs; &clubs;]</code></td>
        <td><code>&clubs; &rarr; &hearts;</code></td>
        <td><code>[&hearts; &hearts; &hearts;]</code></td>
      </tr>
    </table>
  </div>

  <div class="slide">
    <h3>When to use it</h3>
    <ul>
      <li>I have a function from &clubs; to &hearts;</li>
      <li>But instead of a &clubs;, I get a list of &clubs;, like [&clubs; &clubs; &clubs;].</li>
      <li>I want to apply my &clubs; &rarr; &hearts; function to all the &clubs; in the list and get a new list of &hearts;, i.e. [&hearts; &hearts; &hearts;]</li>
      <li>In other words, I want to <em>map the function <code>f</code> over the list <code>xs</code></em></li> 
      <li>In <em>other</em> other words, I want to <em>lift</em> the function &clubs; &rarr; &hearts; into list context. (How is that for code reuse?)</li>
    </ul>
    <p>Note that <code>map</code> can be for more than just lists. We'll get back to that.</p>
  </div>
</section>

<section class="slide">
  <h2>Lists: <code>map</code></h2>
  <div>
    <h3>Example #1: Increment all items in a list</h3>
    <textarea id="map1" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const inc = n => n + 1;
const ns = [1, 2, 3];

const result = R.map(inc, ns);

console.log(result);
    </textarea>
  </div>

  <div class="slide">
    <h3>Example #2: Map elements to another type</h3>
    <textarea id="map2" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const ns = [114, 97, 109, 100, 97];
const result = R.map(String.fromCharCode, ns);

console.log(result);
    </textarea>
  </div>
</section>

<section class="slide">
  <h2>Lists: <code>map</code></h2>

  <h3>Example #2: Comparison</h3>
  <div>
    <textarea id="tomap1" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">var i, upper, out = [];
var xs = ['a', 'b', 'c', 'd', 'e'];
for (i = 0; i < xs.length; i++) {
  upper = xs[i].toUpperCase();
  out.push(upper)
}
console.log(out);
    </textarea>
  </div>

  <div class="slide">
    <textarea id="tomap2" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">var xs = ['a', 'b', 'c', 'd', 'e'];
const out = R.map(R.toUpper, xs);
console.log(out);
    </textarea>
  </div>
</section>

<section class="slide">
  <h2>Lists: <code>map</code></h2>

  <p>So what is the difference?
  It is all about <em class="hot">composition</em>.</p>

  <p>Suppose we need to daisy-chain these three transformations together:</p>
  <ul>
    <li>Increment a list of numbers</li>
    <li>Change to string by char code</li>
    <li>Convert to upper case</li>
  </ul>

</section>

<section class="slide">
  <h2>Lists: <code>map</code></h2>
  <h3>First try</h3>
  <div>
    <textarea id="mapcomp" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const xs = [113, 96, 108, 99, 96];
const allTheThings = R.compose(
  R.map(R.toUpper),
  R.map(String.fromCharCode),
  R.map(R.inc)
);
console.log(allTheThings(xs));
    </textarea>
  </div>

  <p class="slide">We can do better than this.</p>
  <div class="slide">
    <h3>Second try</h3>
    <textarea id="mapcomp2" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const xs = [113, 96, 108, 99, 96];
const allTheThings = R.map(
  R.compose(R.toUpper, String.fromCharCode, R.inc)
);
console.log(allTheThings(xs));
    </textarea>
  </div>

  <p class="slide">That's better! But we can pull out that composed function; maybe we can reuse it elsewhere.</p>
  <div class="slide">
    <h3>Third try</h3>
    <textarea id="mapcomp3" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const xs = [113, 96, 108, 99, 96];
const theThing = R.compose(R.toUpper, String.fromCharCode, R.inc); // naming things is hard
const allTheThings = R.map(theThing);
console.log(allTheThings(xs));
    </textarea>
  </div>
</section>


<section class="slide">
  <h2>Lists: <code>map</code></h2>
  <p>We can do these rewrites <em>confidently</em> because <code>map</code> must obey <em class="hot">laws</em></p>
</section>


<section class="slide">
  <h2>Lists: <code>map</code> Laws</h2>

  <div>
    <h4>Identity Law</h4>
    <p><code>map id = id</code></p>
    <textarea id="map_id_law" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const id = x => x;
const mapId = R.map(id);

console.log(mapId([1, 2, 3]), "equals", id([1, 2, 3]));
    </textarea>
  </div>

  <div>
    <h4>Composition Law</h4>
    <p><code>compose(map(f), map(g)) = map(compose(f, g))</code></p>
    <textarea id="map_compose_law" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const f = n => String.fromCharCode(n);
const g = n => n + 1;
const ns = [65, 66, 67];

console.log(R.compose(R.map(f), R.map(g))(ns), "equals", R.map(R.compose(f, g), (ns)));
    </textarea>
  </div>


</section>


<section class="slide">
  <h2>Lists: <code>filter</code></h2>

  <h3>Definition</h3>
  <p><code>R.filter(f, xs)</code> creates a new list by applying a predicate <code>f</code> to the list <code>xs</code>, and returns only the elements that satisfy the predicate.</p> 


  <div class="slide showme">
    <h3>Pattern</h3>
    <table class="patterns">
      <tr>
        <th></th>
        <th>In</th>
        <th>Function</th>
        <th>Out</th>
      </tr>
      <tr>
        <td>filter</td>
        <td><code>[&clubs; &clubs; &clubs;]</code></td>
        <td><code>&clubs; &rarr; Boolean</code></td>
        <td><code>[&clubs; &hellip;]</code></td>
      </tr>
    </table>
  </div>

  <div class="slide">
    <h3>When to use it</h3>
    <ul>
      <li>I want to select only certain elements of a list.</li> 
      <li>I have a function from &clubs; to Boolean that describes the elements I want.</li>
    </ul>
  </div>

</section>

<section class="slide">
  <h2>Lists: <code>filter</code></h2>
  
  <h3><code>filter</code> rules: Analogous to SELECT</h3>

  <div>
    <p><code>(filter f) . (filter g) = filter (\x -&gt; (f x) &amp;&amp; (g x))</code></p>
    <textarea id="filter_algebra" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const ns = [7, 8, 9, 10, 11, 12, 13, 14];
const gt10 = x => x > 10;
const even = x => x % 2 === 0;

console.log(R.compose(R.filter(gt10), R.filter(even))(ns), "equals", R.filter(x => gt10(x) && even(x))(ns));
    </textarea>

  </div>

  <div>
    <p><code>(filter f) . (filter g) = (filter g) . (filter f)</code></p>
    <textarea id="filter_algebra" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const ns = [7, 8, 9, 10, 11, 12, 13, 14];
const gt10 = x => x > 10;
const even = x => x % 2 === 0;

console.log(R.compose(R.filter(gt10), R.filter(even))(ns), "equals", R.compose(R.filter(even), R.filter(gt10))(ns));
    </textarea>
  </div>

</section>


<section class="slide">
  <h2>Lists: <code>reduce</code></h2>

</section>

<section class="slide">
  <h2>Lists: <code>map, filter, reduce</code></h2>

  <p>You can stop here and probably be perfectly happy and productive.</p>
</section>

<section class="slide">
  <h2>Lists: <code>chain</code></h2>

</section>


<section class="slide">
  <h2>Lists: <code>find</code></h2>

  <p>There is something <em>different</em> about <code>find</code> &hellip;</p>
</section>


<section class="slide">
  <h2>Lists & Composition</h2>

  <p>How would you write a function to get the sum of a 2D matrix? For example,
  given a matrix <code>[[1, 2], [3, 4]]</code>, your function should return <code>10</code>
  </p>

  <div>
    <textarea id="mxSum2" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const mx = [
  [2, 34, 1, 17],
  [5, 9, 11, 10],
  [21, 11, 1, 3],
  [44, 15, 8, 12]
];
const mxSum2 = mx => {
  // return the sum of the matrix
}
    </textarea>
  </div>
</section>

<section class="slide">
  <h2>Lists & Composition</h2>

  <p>Here's a nice way to do it:</p>

  <div>
    <textarea id="mxSum2_solution" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">const mx = [
  [2, 34, 1, 17],
  [5, 9, 11, 10],
  [21, 11, 1, 3],
  [44, 15, 8, 12]
];

// 1. start with a helper that adds two numbers
const add = (x, y) => x + y;

// 2. another helper to fold `add` over a list
const sum = R.reduce(add, 0);

// 3. Compose
const mxSum2 = R.compose(sum, R.map(sum)); 

console.log("mxSum2(mx) equals", mxSum2(mx));
    </textarea>
  </div>
</section>

<section class="slide">
  <h2>Lists & Composition</h2>

  <p>That was fun! Now let's write a function for a 3D matrix.
  </p>

  <div class="slide">
    <textarea id="mxSum3_solution" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">
const mxSum3 = R.compose(sum, R.map(mxSum2)); 
    </textarea>
  </div>

  <p class="slide">How about 4D?</p>
  <div class="slide">
    <textarea id="mxSum4_solution" class="code" name="code" mode="javascript" style="display: none" runnable="true" globals="R">
const mxSum4 = R.compose(sum, R.map(mxSum3)); 
    </textarea>
  </div>

  <div class="slide">
    <p> &hellip; and so on. </p>


  </div>
</section>

<section class="slide">
  <h2>Lists & Composition</h2>

  <p>Let's write a function for a <em>N</em>-dimensional matrix.</p>
  <p>What pattern is would that be?</p>
</section>


<section class="slide">
<h2>Final Thought</h2>

<blockquote>Simplicity is hard work. But, there's a huge payoff. The person who has a genuinely simpler system - a system made out of genuinely simple parts, is going to be able to affect the greatest change with the least work. He's going to kick your ass. He's gonna spend more time simplifying things up front and in the long haul he's gonna wipe the plate with you because he'll have that ability to change things when you're struggling to push elephants around.
  
  <p>&mdash; Rich Hickey</p>
</blockquote>

<div>
  <img src="img/push-elephant.jpg" />
</div>
</section>


<!-- End slides. -->


<!-- Begin extension snippets. Add or remove as needed. -->

<!-- deck.navigation snippet -->
<a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
<a href="#" class="deck-next-link" title="Next">&#8594;</a>

<!-- deck.status snippet -->
<p class="deck-status">
	<span class="deck-status-current"></span>
	/
	<span class="deck-status-total"></span>
</p>

<!-- deck.goto snippet -->
<form action="." method="get" class="goto-form">
	<label for="goto-slide">Go to slide:</label>
	<input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
	<datalist id="goto-datalist"></datalist>
	<input type="submit" value="Go">
</form>

<!-- deck.hash snippet -->
<a href="." title="Permalink to this slide" class="deck-permalink">#</a>

<!-- End extension snippets. -->


<!-- Required JS files. -->
<script src="jquery-1.7.2.min.js"></script>
<script src="core/deck.core.js"></script>

<!-- Extension JS files. Add or remove as needed. -->
<script src="core/deck.core.js"></script>
<script src="extensions/hash/deck.hash.js"></script>
<script src="extensions/menu/deck.menu.js"></script>
<script src="extensions/goto/deck.goto.js"></script>
<script src="extensions/status/deck.status.js"></script>
<script src="extensions/navigation/deck.navigation.js"></script>
<!--script src="extensions/scale/deck.scale.js"></script-->

<!-- include the base codemirror code. -->
<script src="extensions/codemirror/codemirror.js"></script>

<!-- javascript -->
<script src="extensions/codemirror/mode/javascript/javascript.js"></script>

<!-- Plugin code -->
<script src="extensions/codemirror/deck.codemirror.js"></script>

<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>
	$(function() {
		$.deck('.slide');
	});
</script>
</body>
</html>
